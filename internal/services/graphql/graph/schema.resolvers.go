package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"math"

	"github.com/peygy/medapp/internal/pkg/grpc"
	pbAuth "github.com/peygy/medapp/internal/pkg/protos/graph_auth"
	pbCrew "github.com/peygy/medapp/internal/pkg/protos/graph_crew"
	pbHealth "github.com/peygy/medapp/internal/pkg/protos/graph_health"
	pbNote "github.com/peygy/medapp/internal/pkg/protos/graph_note"
	"github.com/peygy/medapp/internal/services/graphql/graph/model"
)

// SignUp is the resolver for the signUp field.
func (r *mutationResolver) SignUp(ctx context.Context, input model.AuthData) (*model.AuthPayload, error) {
	authConnIdx := findServiceIndex(r.GrpcServices, "auth_service")
	client := pbAuth.NewAuthServiceClient(r.GrpcServices[authConnIdx].Conn)

	responce, err := client.SignUp(ctx, &pbAuth.UserRequest{
		Username: input.Username,
		Password: input.Password,
	})
	if err != nil {
		fmt.Print(err)
		return nil, fmt.Errorf("graphql: could not sign up new user: %v", err)
	}

	return &model.AuthPayload{
		UserID: responce.GetUserId(),
		Role:   responce.GetRole(),
	}, nil
}

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.AuthData) (*model.AuthPayload, error) {
	authConnIdx := findServiceIndex(r.GrpcServices, "auth_service")
	client := pbAuth.NewAuthServiceClient(r.GrpcServices[authConnIdx].Conn)

	responce, err := client.SignIn(ctx, &pbAuth.UserRequest{
		Username: input.Username,
		Password: input.Password,
	})
	if err != nil {
		fmt.Print(err)
		return nil, fmt.Errorf("graphql: could not sign in exists user: %v", err)
	}

	return &model.AuthPayload{
		UserID: responce.GetUserId(),
		Role:   responce.GetRole(),
	}, nil
}

// UpdateUserHealthData is the resolver for the updateUserHealthData field.
func (r *mutationResolver) UpdateUserHealthData(ctx context.Context, input model.UpdateUserHealthDataInput) (*model.UserAccountPayload, error) {
	authConnIdx := findServiceIndex(r.GrpcServices, "auth_service")
	authClient := pbAuth.NewAuthServiceClient(r.GrpcServices[authConnIdx].Conn)
	healthConnIdx := findServiceIndex(r.GrpcServices, "health_service")
	healthClient := pbHealth.NewHealthServiceClient(r.GrpcServices[healthConnIdx].Conn)

	responceAuth, err := authClient.GetUserInfo(ctx, &pbAuth.UserInfoRequest{
		UserId: input.UserID,
	})
	if err != nil {
		fmt.Print(err)
		return nil, fmt.Errorf("graphql: could not get user name: %v", err)
	}

	responceHealth, err := healthClient.UpdateHealthData(ctx, &pbHealth.UpdateHealthDataRequest{
		UserId:   input.UserID,
		Age:      int32(*input.Age),
		Height:   float32(*input.Height),
		Weight:   float32(*input.Weight),
		Pulse:    int32(*input.Pulse),
		Pressure: *input.Pressure,
	})
	if err != nil {
		fmt.Print(err)
		return nil, fmt.Errorf("graphql: could not get user health data: %v", err)
	}

	return &model.UserAccountPayload{
		Username:      responceAuth.GetUserName(),
		Age:           int(responceHealth.GetAge()),
		Height:        float64(responceHealth.GetHeight()),
		Weight:        float64(responceHealth.GetWeight()),
		Pulse:         int(responceHealth.GetPulse()),
		Pressure:      responceHealth.GetPressure(),
		DailyWater:    toFloat64Pointer(responceHealth.GetDailyWater()),
		BodyMassIndex: toFloat64Pointer(responceHealth.GetBodyMassIndex()),
	}, nil
}

// AddVisitRecord is the resolver for the addVisitRecord field.
func (r *mutationResolver) AddVisitRecord(ctx context.Context, input model.AddVisitRecordInput) (bool, error) {
	noteConnIdx := findServiceIndex(r.GrpcServices, "note_service")
	noteClient := pbNote.NewVisitServiceClient(r.GrpcServices[noteConnIdx].Conn)

	responce, err := noteClient.AddVisitRecord(ctx, &pbNote.AddVisitRecordRequest{
		UserId:     input.UserID,
		DoctorName: input.DoctorName,
		VisitDate:  input.VisitDate,
	})
	if err != nil {
		fmt.Print(err)
		return false, fmt.Errorf("graphql: could not add visit for name: %v", err)
	}

	return responce.GetSuccess(), nil
}

// GetUserInfo is the resolver for the getUserInfo field.
func (r *queryResolver) GetUserInfo(ctx context.Context, input model.UserAccountData) (*model.UserAccountPayload, error) {
	authConnIdx := findServiceIndex(r.GrpcServices, "auth_service")
	authClient := pbAuth.NewAuthServiceClient(r.GrpcServices[authConnIdx].Conn)
	healthConnIdx := findServiceIndex(r.GrpcServices, "health_service")
	healthClient := pbHealth.NewHealthServiceClient(r.GrpcServices[healthConnIdx].Conn)

	responceAuth, err := authClient.GetUserInfo(ctx, &pbAuth.UserInfoRequest{
		UserId: input.UserID,
	})
	if err != nil {
		fmt.Print(err)
		return nil, fmt.Errorf("graphql: could not get user name: %v", err)
	}

	responceHealth, err := healthClient.GetHealthData(ctx, &pbHealth.GetHealthDataRequest{
		UserId: input.UserID,
	})
	if err != nil {
		fmt.Print(err)
		return nil, fmt.Errorf("graphql: could not get user health data: %v", err)
	}

	return &model.UserAccountPayload{
		Username:      responceAuth.GetUserName(),
		Age:           int(responceHealth.GetAge()),
		Height:        float64(responceHealth.GetHeight()),
		Weight:        float64(responceHealth.GetWeight()),
		Pulse:         int(responceHealth.GetPulse()),
		Pressure:      responceHealth.GetPressure(),
		DailyWater:    toFloat64Pointer(responceHealth.GetDailyWater()),
		BodyMassIndex: toFloat64Pointer(responceHealth.GetBodyMassIndex()),
	}, nil
}

// GetUserVisitRecords is the resolver for the getUserVisitRecords field.
func (r *queryResolver) GetUserVisitRecords(ctx context.Context, input model.UserAccountData) ([]*model.VisitRecord, error) {
	noteConnIdx := findServiceIndex(r.GrpcServices, "note_service")
	noteClient := pbNote.NewVisitServiceClient(r.GrpcServices[noteConnIdx].Conn)

	responce, err := noteClient.GetUserVisitRecords(ctx, &pbNote.GetUserVisitRecordsRequest{
		UserId: input.UserID,
	})
	if err != nil {
		fmt.Print(err)
		return nil, fmt.Errorf("graphql: could not get user personal info: %v", err)
	}

	visits := make([]*model.VisitRecord, len(responce.GetVisitRecords()))
	for i, visit := range responce.GetVisitRecords() {
		visits[i] = &model.VisitRecord{
			RecordNumber:   visit.GetRecordNumber(),
			DoctorName:     visit.GetDoctorName(),
			Specialization: visit.GetSpecialization(),
			VisitDate:      visit.GetVisitDate(),
		}
	}

	return visits, nil
}

// GetDoctors is the resolver for the getDoctors field.
func (r *queryResolver) GetDoctors(ctx context.Context) ([]*model.Doctor, error) {
	crewConnIdx := findServiceIndex(r.GrpcServices, "crew_service")
	crewClient := pbCrew.NewCrewServiceClient(r.GrpcServices[crewConnIdx].Conn)

	responce, err := crewClient.GetDoctors(ctx, &pbCrew.GetDoctorsRequest{})
	if err != nil {
		fmt.Print(err)
		return nil, fmt.Errorf("graphql: could not get list of doctors: %v", err)
	}

	doctors := make([]*model.Doctor, len(responce.GetDoctors()))
	for i, doc := range responce.GetDoctors() {
		doctors[i] = &model.Doctor{
			DoctorID:        doc.GetDoctorId(),
			DoctorName:      doc.GetDoctorName(),
			Specialization:  doc.GetSpecialization(),
			ExperienceYears: int(doc.GetExperienceYears()),
		}
	}

	return doctors, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func findServiceIndex(services []grpc.GrpcService, name string) int {
	for i, service := range services {
		if service.Name == name {
			return i
		}
	}
	return -1
}
func toFloat64Pointer(value float32) *float64 {
	if math.IsNaN(float64(value)) || math.IsInf(float64(value), 0) {
		return nil
	}
	result := float64(value)
	return &result
}
